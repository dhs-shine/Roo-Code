/**
 * CommandStreamManager
 *
 * Manages streaming of command execution output with code fence wrapping.
 * Handles both live command execution events and final command_output messages.
 *
 * Extracted from session.ts to separate the command output streaming concern.
 */

import type { ClineMessage } from "@roo-code/types"

import type { IDeltaTracker, IAcpLogger, SendUpdateFn } from "./interfaces.js"

// =============================================================================
// Types
// =============================================================================

/**
 * Information about a pending command execution.
 */
export interface PendingCommand {
	toolCallId: string
	command: string
	ts: number
}

/**
 * Options for creating a CommandStreamManager.
 */
export interface CommandStreamManagerOptions {
	/** Delta tracker for tracking already-sent content */
	deltaTracker: IDeltaTracker
	/** Callback to send session updates */
	sendUpdate: SendUpdateFn
	/** Logger instance */
	logger: IAcpLogger
}

// =============================================================================
// CommandStreamManager Class
// =============================================================================

/**
 * Manages command output streaming with proper code fence wrapping.
 *
 * Responsibilities:
 * - Track pending command tool calls
 * - Handle live command execution output (with code fences)
 * - Handle final command_output messages
 * - Send tool_call_update notifications
 */
export class CommandStreamManager {
	/**
	 * Track pending command tool calls for the "Run Command" UI.
	 * Maps tool call ID to command info.
	 */
	private pendingCommandCalls: Map<string, PendingCommand> = new Map()

	/**
	 * Track which command executions have sent the opening code fence.
	 * Used to wrap command output in markdown code blocks.
	 */
	private commandCodeFencesSent: Set<string> = new Set()

	/**
	 * Map executionId → toolCallId for robust command output routing.
	 * The executionId is generated by the extension when the command starts,
	 * so we establish this mapping when we first see output for an executionId.
	 * This ensures streaming output goes to the correct tool call, even with
	 * concurrent commands.
	 */
	private executionToToolCallId: Map<string, string> = new Map()

	private readonly deltaTracker: IDeltaTracker
	private readonly sendUpdate: SendUpdateFn
	private readonly logger: IAcpLogger

	constructor(options: CommandStreamManagerOptions) {
		this.deltaTracker = options.deltaTracker
		this.sendUpdate = options.sendUpdate
		this.logger = options.logger
	}

	// ===========================================================================
	// Public API
	// ===========================================================================

	/**
	 * Track a new pending command.
	 * Called when a command tool call is approved.
	 */
	trackCommand(toolCallId: string, command: string, ts: number): void {
		this.pendingCommandCalls.set(toolCallId, { toolCallId, command, ts })
	}

	/**
	 * Handle a command_output message from the extension.
	 * This handles the final tool_call_update for completion, plus the closing fence.
	 *
	 * NOTE: Streaming output is handled by handleExecutionOutput().
	 * This method handles:
	 * 1. Sending the closing code fence as agent_message_chunk (if streaming occurred)
	 * 2. Sending the final tool_call_update with status "completed"
	 */
	handleCommandOutput(message: ClineMessage): void {
		const output = message.text || ""
		const isPartial = message.partial === true

		// Skip partial updates - streaming is handled by handleExecutionOutput()
		if (isPartial) {
			return
		}

		// Handle completion - update the tool call UI
		const pendingCall = this.findMostRecentPendingCommand()

		if (pendingCall) {
			// Send closing code fence as agent_message_chunk if we had streaming output
			const hadStreamingOutput = this.commandCodeFencesSent.has(pendingCall.toolCallId)
			if (hadStreamingOutput) {
				this.sendUpdate({
					sessionUpdate: "agent_message_chunk",
					content: { type: "text", text: "```\n" },
				})
				this.commandCodeFencesSent.delete(pendingCall.toolCallId)
			}

			// Command completed - send final tool_call_update with completed status
			// Note: Zed doesn't display tool_call_update content, so we just mark it complete
			this.sendUpdate({
				sessionUpdate: "tool_call_update",
				toolCallId: pendingCall.toolCallId,
				status: "completed",
				rawOutput: { output },
			})
			this.pendingCommandCalls.delete(pendingCall.toolCallId)
		}
	}

	/**
	 * Handle streaming command execution output (live terminal output).
	 * This provides real-time output during command execution.
	 *
	 * Sends output as agent_message_chunk messages for Zed visibility.
	 * The tool_call UI is updated separately in session-event-handler.
	 *
	 * Output is wrapped in markdown code blocks:
	 * - Opening fence ``` sent on first chunk
	 * - Subsequent chunks sent as-is (deltas only)
	 * - Closing fence ``` sent in handleCommandOutput()
	 *
	 * Uses executionId → toolCallId mapping for robust routing.
	 */
	handleExecutionOutput(executionId: string, output: string): void {
		// Find or establish the toolCallId for this executionId
		let toolCallId = this.executionToToolCallId.get(executionId)

		if (!toolCallId) {
			// First output for this executionId - establish the mapping
			const pendingCall = this.findMostRecentPendingCommand()
			if (!pendingCall) {
				return
			}
			toolCallId = pendingCall.toolCallId
			this.executionToToolCallId.set(executionId, toolCallId)
		}

		// Use executionId as the message key for delta tracking
		const delta = this.deltaTracker.getDelta(executionId, output)
		if (!delta) {
			return
		}

		// Send opening code fence on first chunk
		const isFirstChunk = !this.commandCodeFencesSent.has(toolCallId)
		if (isFirstChunk) {
			this.commandCodeFencesSent.add(toolCallId)
			this.sendUpdate({
				sessionUpdate: "agent_message_chunk",
				content: { type: "text", text: "```\n" },
			})
		}

		// Send the delta as agent_message_chunk for Zed visibility
		this.sendUpdate({
			sessionUpdate: "agent_message_chunk",
			content: { type: "text", text: delta },
		})
	}

	/**
	 * Check if a message is a command_output message that this manager handles.
	 */
	isCommandOutputMessage(message: ClineMessage): boolean {
		return message.type === "say" && message.say === "command_output"
	}

	/**
	 * Reset state for a new prompt.
	 * Call when starting a new prompt to clear all pending state.
	 */
	reset(): void {
		// Clear all pending commands - any from previous prompts are now stale
		// and would cause duplicate completion messages if not cleaned up
		this.pendingCommandCalls.clear()
		this.commandCodeFencesSent.clear()
		this.executionToToolCallId.clear()
	}

	/**
	 * Get the number of pending commands (for testing/debugging).
	 */
	getPendingCommandCount(): number {
		return this.pendingCommandCalls.size
	}

	/**
	 * Check if there are any open code fences (for testing/debugging).
	 */
	hasOpenCodeFences(): boolean {
		return this.commandCodeFencesSent.size > 0
	}

	// ===========================================================================
	// Private Methods
	// ===========================================================================

	/**
	 * Find the most recent pending command call.
	 */
	private findMostRecentPendingCommand(): PendingCommand | undefined {
		let pendingCall: PendingCommand | undefined

		for (const [, call] of this.pendingCommandCalls) {
			if (!pendingCall || call.ts > pendingCall.ts) {
				pendingCall = call
			}
		}

		return pendingCall
	}
}
